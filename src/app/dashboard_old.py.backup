"""
üéØ DASHBOARD STREAMLIT - GitHub Stars Predictor
Visualisation des donn√©es collect√©es depuis Azure Blob Storage
"""

import streamlit as st
import plotly.express as px
import plotly.graph_objects as go
import pandas as pd
import numpy as np
from datetime import datetime, timedelta

# Import des fonctions utilitaires
from src.core.azure_storage import AzureStorage
from src.core.settings import Settings
from src.core.data_build import snapshots_to_dataframe

def load_all_snapshots() -> list[dict]:
    storage = AzureStorage()
    blob_names = storage.list_blobs(Settings.SNAPSHOT_PREFIX)
    snapshots = []
    for name in blob_names:
        snap = storage.download_json(name)
        if snap and "repos" in snap:
            snapshots.append(snap)
    return snapshots

def calculate_growth_stats(df: pd.DataFrame) -> pd.DataFrame:
    """
    Stats par repo sur la p√©riode (initial, current, croissance, daily growth, category).
    """
    df = df.sort_values(["repo_id", "date"]).copy()
    first = df.groupby("repo_id").first().reset_index()
    last = df.groupby("repo_id").last().reset_index()

    stats = first[["repo_id", "full_name", "language", "stars"]].rename(columns={"stars": "initial_stars"})
    stats = stats.merge(
        last[["repo_id", "stars"]].rename(columns={"stars": "current_stars"}),
        on="repo_id",
        how="inner"
    )

    # jours observ√©s par repo
    n_days = df.groupby("repo_id")["date"].nunique().reset_index().rename(columns={"date": "n_days"})
    stats = stats.merge(n_days, on="repo_id", how="left")

    stats["stars_growth"] = stats["current_stars"] - stats["initial_stars"]
    stats["daily_growth"] = stats["stars_growth"] / stats["n_days"].clip(lower=1)
    stats["stars_growth_pct"] = (stats["stars_growth"] / (stats["initial_stars"] + 1)) * 100

    # Cat√©gories simples (tu peux ajuster)
    # explosion = top 10% en daily_growth, faible = milieu, stable = bas
    q90 = stats["daily_growth"].quantile(0.90)
    q50 = stats["daily_growth"].quantile(0.50)

    def cat(x):
        if x >= q90:
            return "üî• EXPLOSION"
        if x >= q50:
            return "üìà CROISSANCE"
        return "üßä STABLE"

    stats["category"] = stats["daily_growth"].apply(cat)
    return stats

def get_repo_timeline(df: pd.DataFrame, full_name: str) -> pd.DataFrame:
    return df[df["full_name"] == full_name].sort_values("date")

# =============================================================================
# CONFIGURATION DE LA PAGE
# =============================================================================

st.set_page_config(
    page_title="GitHub Stars Predictor",
    page_icon="‚≠ê",
    layout="wide",
    initial_sidebar_state="expanded"
)

# CSS personnalis√©
st.markdown("""
    <style>
    .main {
        padding: 0rem 1rem;
    }
    .stMetric {
        background-color: #f0f2f6;
        padding: 15px;
        border-radius: 10px;
    }
    h1 {
        color: #1f77b4;
    }
    </style>
""", unsafe_allow_html=True)

# =============================================================================
# CHARGEMENT DES DONN√âES (avec cache)
# =============================================================================

@st.cache_data(ttl=600)  # Cache pendant 10 minutes
@st.cache_data(ttl=600)
def load_data():
    """Charge toutes les donn√©es depuis Azure"""
    try:
        with st.spinner("Chargement des donn√©es depuis Azure..."):
            snapshots = load_all_snapshots()

        if not snapshots:
            st.error("Aucun snapshot trouv√© sur Azure")
            return None, None

        df = snapshots_to_dataframe(snapshots)
        stats_df = calculate_growth_stats(df)
        return df, stats_df

    except Exception as e:
        st.error(f"Erreur chargement donn√©es: {e}")
        return None, None


# =============================================================================
# HEADER
# =============================================================================

st.title("‚≠ê GitHub Stars Predictor Dashboard")
st.markdown("---")

# Charger les donn√©es
df, stats_df = load_data()

if df is None or stats_df is None:
    st.stop()

# =============================================================================
# SIDEBAR - FILTRES
# =============================================================================

st.sidebar.header("üéõÔ∏è Filtres")

# S√©lection de page
page = st.sidebar.radio(
    "Navigation",
    ["üìä Vue d'ensemble", "üìà √âvolution temporelle", "üîç Analyse d√©taill√©e", "üèÜ Classements", "üß™ Backtest MLOps"]
)


st.sidebar.markdown("---")

# Informations g√©n√©rales
st.sidebar.markdown("### ‚ÑπÔ∏è Informations")
st.sidebar.info(f"""
**P√©riode de collecte:**  
Du {df['date'].min().strftime('%d/%m/%Y')}  
au {df['date'].max().strftime('%d/%m/%Y')}

**Nombre de jours:** {(df['date'].max() - df['date'].min()).days + 1}  
**Repos suivis:** {df['repo_id'].nunique()}  
**Snapshots:** {df['date'].nunique()}
""")

# =============================================================================
# PAGE 1 : VUE D'ENSEMBLE
# =============================================================================

if page == "üìä Vue d'ensemble":
    st.header("üìä Vue d'ensemble g√©n√©rale")
    
    # M√©triques principales
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric(
            "Repos suivis",
            f"{stats_df['repo_id'].nunique():,}",
            delta=None
        )
    
    with col2:
        total_stars = stats_df['current_stars'].sum()
        st.metric(
            "Total Stars",
            f"{total_stars:,}",
            delta=None
        )
    
    with col3:
        avg_growth = stats_df['daily_growth'].mean()
        st.metric(
            "Croissance moy/jour",
            f"{avg_growth:.1f}",
            delta=None
        )
    
    with col4:
        explosion_count = len(stats_df[stats_df['category'] == 'üî• EXPLOSION'])
        st.metric(
            "Repos en explosion",
            f"{explosion_count}",
            delta=None
        )
    
    st.markdown("---")
    
    # Distribution des cat√©gories
    col1, col2 = st.columns([1, 2])
    
    with col1:
        st.subheader("üè∑Ô∏è Distribution des cat√©gories")
        
        category_counts = stats_df['category'].value_counts()
        
        fig_pie = px.pie(
            values=category_counts.values,
            names=category_counts.index,
            title="R√©partition des repos par cat√©gorie",
            hole=0.4,
            color_discrete_sequence=['#ff4444', '#ffa500', '#44ff44']
        )
        st.plotly_chart(fig_pie, use_container_width=True)
    
    with col2:
        st.subheader("üìä Croissance par cat√©gorie")
        
        category_stats = stats_df.groupby('category').agg({
            'daily_growth': 'mean',
            'stars_growth_pct': 'mean',
            'repo_id': 'count'
        }).reset_index()
        category_stats.columns = ['Cat√©gorie', 'Croissance/jour', 'Croissance %', 'Nombre']
        
        fig_bar = px.bar(
            category_stats,
            x='Cat√©gorie',
            y='Croissance/jour',
            text='Croissance/jour',
            title="Croissance moyenne par cat√©gorie (stars/jour)",
            color='Cat√©gorie',
            color_discrete_sequence=['#ff4444', '#ffa500', '#44ff44']
        )
        fig_bar.update_traces(texttemplate='%{text:.1f}', textposition='outside')
        st.plotly_chart(fig_bar, use_container_width=True)
    
    st.markdown("---")
    
    # Langages les plus populaires
    st.subheader("üíª Langages les plus repr√©sent√©s")
    
    lang_stats = stats_df.groupby('language').agg({
        'repo_id': 'count',
        'current_stars': 'sum',
        'daily_growth': 'mean'
    }).reset_index()
    lang_stats.columns = ['Langage', 'Nombre de repos', 'Total stars', 'Croissance moy/jour']
    lang_stats = lang_stats.sort_values('Nombre de repos', ascending=False).head(10)
    
    fig_lang = px.bar(
        lang_stats,
        x='Langage',
        y='Nombre de repos',
        text='Nombre de repos',
        title="Top 10 langages",
        color='Croissance moy/jour',
        color_continuous_scale='viridis'
    )
    st.plotly_chart(fig_lang, use_container_width=True)

# =============================================================================
# PAGE 2 : √âVOLUTION TEMPORELLE
# =============================================================================

elif page == "üìà √âvolution temporelle":
    st.header("üìà √âvolution temporelle des m√©triques")
    
    # S√©lection de repos √† afficher
    st.sidebar.markdown("### Filtres temporels")
    
    # Top N repos
    top_n = st.sidebar.slider("Afficher top N repos", 5, 50, 10)
    
    # M√©trique √† afficher
    metric = st.sidebar.selectbox(
        "M√©trique √† visualiser",
        ["Stars", "Forks", "Issues ouvertes"]
    )
    
    metric_col = {
        "Stars": "stars",
        "Forks": "forks",
        "Issues ouvertes": "open_issues"
    }[metric]
    
    # S√©lectionner les top repos par croissance
    top_repos = stats_df.nlargest(top_n, 'daily_growth')['full_name'].tolist()
    
    # Filtrer les donn√©es
    df_filtered = df[df['full_name'].isin(top_repos)]
    
    # Graphique d'√©volution
    st.subheader(f"üìä √âvolution de {metric} - Top {top_n} repos en croissance")
    
    fig = px.line(
        df_filtered,
        x='date',
        y=metric_col,
        color='full_name',
        title=f"√âvolution de {metric} au fil du temps",
        labels={'date': 'Date', metric_col: metric},
        markers=True
    )
    
    fig.update_layout(
        hovermode='x unified',
        legend=dict(
            orientation="v",
            yanchor="top",
            y=1,
            xanchor="left",
            x=1.02
        )
    )
    
    st.plotly_chart(fig, use_container_width=True)
    
    st.markdown("---")
    
    # Heatmap des collectes
    st.subheader("üóìÔ∏è Calendrier des collectes")
    
    # Compter les repos collect√©s par date
    daily_counts = df.groupby('date')['repo_id'].count().reset_index()
    daily_counts.columns = ['date', 'count']
    daily_counts['day'] = daily_counts['date'].dt.day
    daily_counts['month'] = daily_counts['date'].dt.month
    daily_counts['year'] = daily_counts['date'].dt.year
    
    fig_heatmap = px.density_heatmap(
        daily_counts,
        x='day',
        y='month',
        z='count',
        title="Nombre de repos collect√©s par jour",
        labels={'day': 'Jour du mois', 'month': 'Mois', 'count': 'Nombre de repos'},
        color_continuous_scale='Blues'
    )
    
    st.plotly_chart(fig_heatmap, use_container_width=True)

# =============================================================================
# PAGE 3 : ANALYSE D√âTAILL√âE
# =============================================================================

elif page == "üîç Analyse d√©taill√©e":
    st.header("üîç Analyse d√©taill√©e par repo")
    
    # S√©lectionner un repo
    repo_names = sorted(df['full_name'].unique())
    selected_repo = st.selectbox("S√©lectionner un repo", repo_names)
    
    if selected_repo:
        # Donn√©es du repo
        repo_timeline = get_repo_timeline(df, selected_repo)
        repo_stats = stats_df[stats_df['full_name'] == selected_repo].iloc[0]
        
        # Informations g√©n√©rales
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.metric("Cat√©gorie", repo_stats['category'])
        
        with col2:
            st.metric(
                "Stars actuelles",
                f"{repo_stats['current_stars']:,}",
                delta=f"+{repo_stats['stars_growth']:,}"
            )
        
        with col3:
            st.metric(
                "Croissance/jour",
                f"{repo_stats['daily_growth']:.2f}",
                delta=f"{repo_stats['stars_growth_pct']:.1f}%"
            )
        
        st.markdown("---")
        
        # Graphiques d'√©volution
        col1, col2 = st.columns(2)
        
        with col1:
            # √âvolution des stars
            fig_stars = go.Figure()
            
            fig_stars.add_trace(go.Scatter(
                x=repo_timeline['date'],
                y=repo_timeline['stars'],
                mode='lines+markers',
                name='Stars',
                line=dict(color='gold', width=3),
                marker=dict(size=8)
            ))
            
            fig_stars.update_layout(
                title="√âvolution des stars",
                xaxis_title="Date",
                yaxis_title="Nombre de stars",
                hovermode='x'
            )
            
            st.plotly_chart(fig_stars, use_container_width=True)
        
        with col2:
            # √âvolution des forks
            fig_forks = go.Figure()
            
            fig_forks.add_trace(go.Scatter(
                x=repo_timeline['date'],
                y=repo_timeline['forks'],
                mode='lines+markers',
                name='Forks',
                line=dict(color='blue', width=3),
                marker=dict(size=8)
            ))
            
            fig_forks.update_layout(
                title="√âvolution des forks",
                xaxis_title="Date",
                yaxis_title="Nombre de forks",
                hovermode='x'
            )
            
            st.plotly_chart(fig_forks, use_container_width=True)
        
        # Croissance quotidienne
        st.subheader("üìä Croissance quotidienne")
        
        # Calculer la croissance jour par jour
        repo_timeline = repo_timeline.sort_values('date')
        repo_timeline['daily_change'] = repo_timeline['stars'].diff()
        
        fig_daily = px.bar(
            repo_timeline[1:],  # Ignorer le premier jour (pas de diff)
            x='date',
            y='daily_change',
            title="Changement quotidien (stars gagn√©es/perdues)",
            labels={'date': 'Date', 'daily_change': 'Stars gagn√©es'},
            color='daily_change',
            color_continuous_scale=['red', 'yellow', 'green']
        )
        
        st.plotly_chart(fig_daily, use_container_width=True)
        
        # Tableau de donn√©es
        st.subheader("üìã Donn√©es brutes")
        st.dataframe(
            repo_timeline[['date', 'stars', 'forks', 'open_issues', 'watchers']].sort_values('date', ascending=False),
            use_container_width=True
        )

# =============================================================================
# PAGE 4 : CLASSEMENTS
# =============================================================================

elif page == "üèÜ Classements":
    st.header("üèÜ Classements et Top performers")
    
    # Filtres
    col1, col2 = st.columns(2)
    
    with col1:
        category_filter = st.multiselect(
            "Filtrer par cat√©gorie",
            stats_df['category'].unique(),
            default=stats_df['category'].unique()
        )
    
    with col2:
        language_filter = st.multiselect(
            "Filtrer par langage",
            stats_df['language'].unique(),
            default=None
        )
    
    # Appliquer filtres
    filtered_stats = stats_df.copy()
    
    if category_filter:
        filtered_stats = filtered_stats[filtered_stats['category'].isin(category_filter)]
    
    if language_filter:
        filtered_stats = filtered_stats[filtered_stats['language'].isin(language_filter)]
    
    # Top repos par croissance absolue
    st.subheader("üî• Top 20 - Plus forte croissance (nombre de stars)")
    
    top_growth = filtered_stats.nlargest(20, 'stars_growth')[
        ['full_name', 'category', 'language', 'initial_stars', 'current_stars', 'stars_growth', 'daily_growth']
    ]
    
    st.dataframe(
        top_growth.style.background_gradient(subset=['stars_growth'], cmap='Reds'),
        use_container_width=True
    )
    
    st.markdown("---")
    
    # Top repos par croissance relative
    st.subheader("üìà Top 20 - Plus forte croissance (pourcentage)")
    
    top_growth_pct = filtered_stats.nlargest(20, 'stars_growth_pct')[
        ['full_name', 'category', 'language', 'initial_stars', 'current_stars', 'stars_growth_pct', 'daily_growth']
    ]
    
    st.dataframe(
        top_growth_pct.style.background_gradient(subset=['stars_growth_pct'], cmap='Greens'),
        use_container_width=True
    )
    
    st.markdown("---")
    
    # Comparaison graphique
    st.subheader("üìä Comparaison des top performers")
    
    top_10 = filtered_stats.nlargest(10, 'daily_growth')
    
    fig = go.Figure()
    
    fig.add_trace(go.Bar(
        name='Croissance/jour',
        x=top_10['full_name'],
        y=top_10['daily_growth'],
        marker_color='lightblue'
    ))
    
    fig.update_layout(
        title="Top 10 repos - Croissance quotidienne",
        xaxis_title="Repo",
        yaxis_title="Stars/jour",
        xaxis_tickangle=-45,
        height=500
    )
    
    st.plotly_chart(fig, use_container_width=True)
elif page == "üß™ Backtest MLOps":
    st.header("üß™ Backtest MLOps ‚Äî Monitoring dans le temps")

    storage = AzureStorage()
    backtest_blob = "monitoring/metrics_history_backtest.json"
    bt = storage.download_json(backtest_blob)

    if not bt or "history" not in bt or len(bt["history"]) == 0:
        st.warning("Aucun historique de backtest trouv√©. Lance le job backtest d‚Äôabord.")
        st.stop()

    hist = pd.DataFrame(bt["history"])
    hist["t"] = pd.to_datetime(hist["t"])
    hist["r2"] = hist["metrics"].apply(lambda x: x.get("r2"))
    hist["mae"] = hist["metrics"].apply(lambda x: x.get("mae"))
    hist["mse"] = hist["metrics"].apply(lambda x: x.get("mse"))

    st.subheader("üìâ R¬≤ dans le temps")
    fig = px.line(hist, x="t", y="r2", markers=True, title="R¬≤ au fil du temps (backtest)")
    st.plotly_chart(fig, use_container_width=True)

    st.subheader("üìè MAE dans le temps")
    fig2 = px.line(hist, x="t", y="mae", markers=True, title="MAE au fil du temps (backtest)")
    st.plotly_chart(fig2, use_container_width=True)

    # Afficher les retrains
    st.subheader("üîÅ Dates de retrain")
    retrains = hist[hist.get("retrained_today", False) == True].copy()
    if len(retrains) == 0:
        st.info("Aucun retrain enregistr√©.")
    else:
        st.dataframe(
            retrains[["t", "r2", "mae", "triggered_retrain", "trigger_reason", "train_rows"]],
            use_container_width=True
        )


# =============================================================================
# FOOTER
# =============================================================================

st.markdown("---")
st.markdown("""
    <div style='text-align: center; color: #888;'>
        <p>üìä GitHub Stars Predictor Dashboard v1.0</p>
        <p>Donn√©es stock√©es sur Azure Blob Storage</p>
    </div>
""", unsafe_allow_html=True)